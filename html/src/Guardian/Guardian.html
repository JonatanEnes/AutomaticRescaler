<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.5.1" />
<title>src.Guardian.Guardian API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id=^header-]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:1px solid #ddd;margin:1em 0 1em 4ch}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}#index .two-column{column-count:2}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.name small{font-weight:normal}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{background:#ffc;font-weight:400;font-size:.8em;width:11em;text-transform:uppercase;padding:0px 8px;border:1px solid #fd6;border-radius:5px;cursor:pointer}.source summary:hover{background:#fe9 !important}.source[open] summary{background:#fda}.source pre{max-height:500px;overflow-y:scroll;margin-bottom:15px}.hlist{list-syle:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink;]</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a,a:visited{text-decoration:underline}a[href]:after{content:" (" attr(href) ")"}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title"><code>src.Guardian.Guardian</code> module</h1>
</header>
<section id="section-intro">
<details class="source">
<summary>Source code</summary>
<pre><code class="python"># /usr/bin/python
from __future__ import print_function

from threading import Thread
import time
import traceback
import logging
from json_logic import jsonLogic

import src.MyUtils.MyUtils as MyUtils
import src.StateDatabase.couchdb as couchdb
import src.StateDatabase.opentsdb as bdwatchdog

BDWATCHDOG_CONTAINER_METRICS = [&#39;proc.cpu.user&#39;, &#39;proc.mem.resident&#39;, &#39;proc.cpu.kernel&#39;, &#39;proc.mem.virtual&#39;]
BDWATCHDOG_APPLICATION_METRICS = [&#39;structure.cpu.usage&#39;, &#39;structure.mem.usage&#39;, &#39;structure.energy.usage&#39;]
GUARDIAN_CONTAINER_METRICS = {
    &#39;structure.cpu.usage&#39;: [&#39;proc.cpu.user&#39;, &#39;proc.cpu.kernel&#39;],
    &#39;structure.mem.usage&#39;: [&#39;proc.mem.resident&#39;]}
GUARDIAN_APPLICATION_METRICS = {
    &#39;structure.cpu.usage&#39;: [&#39;structure.cpu.usage&#39;],
    &#39;structure.mem.usage&#39;: [&#39;structure.mem.usage&#39;],
    &#39;structure.energy.usage&#39;: [&#39;structure.energy.usage&#39;]}
GUARDIAN_METRICS = {&#34;container&#34;: GUARDIAN_CONTAINER_METRICS, &#34;application&#34;: GUARDIAN_APPLICATION_METRICS}
BDWATCHDOG_METRICS = {&#34;container&#34;: BDWATCHDOG_CONTAINER_METRICS, &#34;application&#34;: BDWATCHDOG_APPLICATION_METRICS}

TAGS = {&#34;container&#34;: &#34;host&#34;, &#34;application&#34;: &#34;structure&#34;}

translator_dict = {&#34;cpu&#34;: &#34;structure.cpu.usage&#34;, &#34;mem&#34;: &#34;structure.mem.usage&#34;, &#34;energy&#34;: &#34;structure.energy.usage&#34;}

# RESOURCES = [&#39;cpu&#39;, &#39;mem&#39;, &#39;disk&#39;, &#39;net&#39;, &#39;energy&#39;]

CONFIG_DEFAULT_VALUES = {&#34;WINDOW_TIMELAPSE&#34;: 10, &#34;WINDOW_DELAY&#34;: 10,
                         &#34;EVENT_TIMEOUT&#34;: 40, &#34;DEBUG&#34;: True, &#34;STRUCTURE_GUARDED&#34;: &#34;container&#34;}
SERVICE_NAME = &#34;guardian&#34;

NOT_AVAILABLE_STRING = &#34;n/a&#34;
MAX_PERCENTAGE_REDUCTION_ALLOWED = 50
MAX_ALLOWED_DIFFERENCE_CURRENT_TO_UPPER = 1

NON_ADJUSTABLE_RESOURCES = [&#34;energy&#34;]
CPU_SHARES_PER_WATT = 5  # 7  # How many cpu shares to rescale per watt


class Guardian:
    &#34;&#34;&#34; Guardian class that implements all the logic for this service&#34;&#34;&#34;

    def __init__(self):
        self.opentsdb_handler = bdwatchdog.OpenTSDBServer()
        self.couchdb_handler = couchdb.CouchDBServer()
        self.NO_METRIC_DATA_DEFAULT_VALUE = self.opentsdb_handler.NO_METRIC_DATA_DEFAULT_VALUE
        self.guardable_resources = [&#39;cpu&#39;, &#39;mem&#39;, &#39;energy&#39;]
        self.debug = True

    @staticmethod
    def check_unset_values(value, label):
        if value == NOT_AVAILABLE_STRING:
            raise ValueError(&#34;value for &#39;{0}&#39; is not set or is not available.&#34;.format(label))

    @staticmethod
    def check_invalid_values(value1, label1, value2, label2, resource=&#34;n/a&#34;):
        if value1 &gt; value2:
            raise ValueError(&#34;in resources: {0} value for &#39;{1}&#39;: {2} is greater than value for &#39;{3}&#39;: {4}&#34;.format(
                resource, label1, str(value1), label2, str(value2)))

    @staticmethod
    def try_get_value(d, key):
        &#34;&#34;&#34;
        Parameters:
            d : dict -&gt; A dictionary with strings as keys
            key : string -&gt; A string used as key for a dictionary of integers

        Returns:
            The value stored in the dictionary or a specific value if it is not in it or if it is not an valid integer
        &#34;&#34;&#34;
        try:
            return int(d[key])
        except (KeyError, ValueError):
            return NOT_AVAILABLE_STRING

    @staticmethod
    def is_application(structure):
        return structure[&#34;subtype&#34;] == &#34;application&#34;

    @staticmethod
    def is_container(structure):
        return structure[&#34;subtype&#34;] == &#34;container&#34;

    @staticmethod
    def sort_events(structure_events, event_timeout):
        &#34;&#34;&#34;
        Parameters:
            structure_events : list -&gt; A list of the events triggered in the past for a specific structure
            event_timeout : integer -&gt; A timeout in seconds

        Returns:
            A tuple of lists of events that either fall in the time window between
            (now - timeout) and (now), the valid events, or outside of it, the invalid ones.
        &#34;&#34;&#34;
        valid, invalid = list(), list()
        for event in structure_events:
            if event[&#34;timestamp&#34;] &lt; time.time() - event_timeout:
                invalid.append(event)
            else:
                valid.append(event)
        return valid, invalid

    @staticmethod
    def reduce_structure_events(structure_events):
        &#34;&#34;&#34;
        Parameters:
            structure_events : list -&gt;

        Returns:
            A dictionary with the added up events in a signle dictionary
        &#34;&#34;&#34;
        events_reduced = {&#34;action&#34;: {}}
        for event in structure_events:
            resource = event[&#34;resource&#34;]
            if resource not in events_reduced[&#34;action&#34;]:
                events_reduced[&#34;action&#34;][resource] = {&#34;events&#34;: {&#34;scale&#34;: {&#34;down&#34;: 0, &#34;up&#34;: 0}}}
            for key in event[&#34;action&#34;][&#34;events&#34;][&#34;scale&#34;].keys():
                value = event[&#34;action&#34;][&#34;events&#34;][&#34;scale&#34;][key]
                events_reduced[&#34;action&#34;][resource][&#34;events&#34;][&#34;scale&#34;][key] += value
        return events_reduced[&#34;action&#34;]

    def get_resource_summary(self, resource_label, resources_dict, limits_dict, usages_dict):
        &#34;&#34;&#34;
        Parameters:
            resource_label : string -&gt; the name of the resource to access the dictionaries
            resources_dict : dict -&gt; a dictionary with the metrics (e.g., max, min) of the resources
            limits_dict : dict -&gt; a dictionary with the limits (e.g., lower, upper) of the resources
            usages_dict : dict -&gt; a dictionary with the usages of the resources

        Returns:
            A string that summarizes the state of a resource in terms of its metrics
        &#34;&#34;&#34;
        metrics = resources_dict[resource_label]
        limits = limits_dict[resource_label]

        if not usages_dict or usages_dict[translator_dict[resource_label]] == self.NO_METRIC_DATA_DEFAULT_VALUE:
            usage_value_string = NOT_AVAILABLE_STRING
        else:
            usage_value_string = str(&#34;%.2f&#34; % usages_dict[translator_dict[resource_label]])

        strings = list()
        if not limits_dict and not usages_dict:
            for field in [&#34;max&#34;, &#34;current&#34;, &#34;max&#34;, &#34;min&#34;]:
                strings.append(str(self.try_get_value(metrics, field)))
        else:
            for field in [(&#34;max&#34;, metrics), (&#34;current&#34;, metrics), (&#34;upper&#34;, limits), (&#34;lower&#34;, limits),
                          (&#34;min&#34;, metrics)]:
                strings.append(str(self.try_get_value(field[1], field[0])))
            strings.insert(3, usage_value_string)  # Manually add the usage metric

        return &#34;,&#34;.join(strings)

    @staticmethod
    def adjust_amount(amount, structure_resources, structure_limits):
        &#34;&#34;&#34;
        Parameters:
            * **amount** : *integer* -&gt; a number representing the amount to reduce or increase from the current value
            * **structure_resources** : *dict* -&gt; asdf
            * **structure_limits** : *dict* -&gt; asdf

        Returns:
            The amount adjusted (trimmed) in case it would exceed any limit
        &#34;&#34;&#34;
        expected_value = structure_resources[&#34;current&#34;] + amount
        lower_limit = structure_limits[&#34;lower&#34;] + amount
        max_limit = structure_resources[&#34;max&#34;]
        min_limit = structure_resources[&#34;min&#34;]

        if lower_limit &lt; min_limit:
            # The amount to reduce is too big, adjust it so that the lower limit is set to the minimum
            amount += (min_limit - lower_limit)
        elif expected_value &gt; max_limit:
            # The amount to increase is too big, adjust it so that the current limit is set to the maximum
            amount -= (expected_value - max_limit)

        return amount

    @staticmethod
    def get_amount_from_percentage_reduction(structure, usages, resource, percentage_reduction):
        current_resource_limit = structure[&#34;resources&#34;][resource][&#34;current&#34;]
        current_resource_usage = usages[translator_dict[resource]]
        difference = current_resource_limit - current_resource_usage
        if percentage_reduction &gt; MAX_PERCENTAGE_REDUCTION_ALLOWED:
            percentage_reduction = MAX_PERCENTAGE_REDUCTION_ALLOWED
        amount = int(-1 * (percentage_reduction * difference) / 100)
        return amount

    @staticmethod
    def get_amount_from_fit_reduction(current_resource_limit, boundary, current_resource_usage):
        &#34;&#34;&#34;
        Parameters:
            current_resource_limit : integer -&gt;
            boundary : integer -&gt;
            current_resource_usage : integer -&gt;

        Returns:
            The amount to be reduced from the fit to usage policy.
        &#34;&#34;&#34;
        upper_to_lower_window = boundary
        current_to_upper_window = boundary

        # Set the limit so that the resource usage is placed in between the upper and lower limits
        # and keeping the boundary between the upper and the real resource limits
        desired_applied_resource_limit = \
            current_resource_usage + int(upper_to_lower_window / 2) + current_to_upper_window

        return -1 * (current_resource_limit - desired_applied_resource_limit)

    @staticmethod
    def get_amount_from_proportional_energy_rescaling(structure, resource):
        max_resource_limit = structure[&#34;resources&#34;][resource][&#34;max&#34;]
        current_resource_limit = structure[&#34;resources&#34;][resource][&#34;usage&#34;]
        difference = max_resource_limit - current_resource_limit
        energy_aplification = CPU_SHARES_PER_WATT  # How many cpu shares to rescale per watt
        return int(difference * energy_aplification)

    def get_container_energy_str(self, resources_dict):
        &#34;&#34;&#34;
        Parameters:
            resources_dict : dict -&gt; A dictionary with all the resources&#39; information

        Returns:
            A string that summarizes the state of the enery resource
        &#34;&#34;&#34;
        energy_dict = resources_dict[&#34;energy&#34;]
        string = list()
        for field in [&#34;max&#34;, &#34;usage&#34;, &#34;min&#34;]:
            string.append(str(self.try_get_value(energy_dict, field)))
        return &#34;,&#34;.join(string)

    def adjust_container_state(self, resources, limits):
        for resource in [&#34;cpu&#34;, &#34;mem&#34;]:
            errors = True
            while errors:
                try:
                    self.check_invalid_container_state(resources, limits, resource)
                    errors = False
                except ValueError:
                    # Correct the chain current &gt; upper &gt; lower, including boundary between current and upper
                    boundary = limits[resource][&#34;boundary&#34;]
                    limits[resource][&#34;upper&#34;] = resources[resource][&#34;current&#34;] - boundary
                    limits[resource][&#34;lower&#34;] = max(limits[resource][&#34;upper&#34;] - boundary, resources[resource][&#34;min&#34;])
        return limits

    def check_invalid_container_state(self, resources, limits, resource):
        data = {&#34;res&#34;: resources, &#34;lim&#34;: limits}
        values_tuples = [(&#34;max&#34;, &#34;res&#34;), (&#34;current&#34;, &#34;res&#34;), (&#34;upper&#34;, &#34;lim&#34;), (&#34;lower&#34;, &#34;lim&#34;), (&#34;min&#34;, &#34;res&#34;)]
        values = dict()
        for value, vtype in values_tuples:
            values[value] = self.try_get_value(data[vtype][resource], value)
        values[&#34;boundary&#34;] = data[&#34;lim&#34;][resource][&#34;boundary&#34;]

        # Check values are set and valid, except for current as it may have not been persisted yet
        for value in values:
            self.check_unset_values(values[value], value)

        # Check if the first value is greater than the second
        # check the full chain &#34;max &gt; upper &gt; current &gt; lower &gt; min&#34;
        if values[&#34;current&#34;] != NOT_AVAILABLE_STRING:
            self.check_invalid_values(values[&#34;current&#34;], &#34;current&#34;, values[&#34;max&#34;], &#34;max&#34;)
        self.check_invalid_values(values[&#34;upper&#34;], &#34;upper&#34;, values[&#34;current&#34;], &#34;current&#34;, resource=resource)
        self.check_invalid_values(values[&#34;lower&#34;], &#34;lower&#34;, values[&#34;upper&#34;], &#34;upper&#34;, resource=resource)
        self.check_invalid_values(values[&#34;min&#34;], &#34;min&#34;, values[&#34;lower&#34;], &#34;lower&#34;, resource=resource)

        # Check that there is a boundary between values, like the current and upper, so
        # that the limit can be surpassed
        if values[&#34;current&#34;] != NOT_AVAILABLE_STRING:
            if values[&#34;current&#34;] - values[&#34;boundary&#34;] &lt; values[&#34;upper&#34;]:
                raise ValueError(
                    &#34;value for &#39;current&#39;: {0} is too close (less than {1}) to value for &#39;upper&#39;: {2}&#34;.format(
                        str(values[&#34;current&#34;]), str(values[&#34;boundary&#34;]), str(values[&#34;upper&#34;])))

            elif values[&#34;current&#34;] - values[&#34;boundary&#34;] &gt; values[&#34;upper&#34;]:
                raise ValueError(
                    &#34;value for &#39;current&#39;: {0} is too far (more than {1}) from value for &#39;upper&#39;: {2}&#34;.format(
                        str(values[&#34;current&#34;]), str(values[&#34;boundary&#34;]), str(values[&#34;upper&#34;])))

    def match_usages_and_limits(self, structure_name, rules, usages, limits, resources):
        events = []
        data = dict()

        for resource in self.guardable_resources:
            if resource in resources:
                data[resource] = {
                    &#34;limits&#34;: {resource: limits[resource]},
                    &#34;structure&#34;: {resource: resources[resource]}}

        for usage_metric in usages:
            keys = usage_metric.split(&#34;.&#34;)
            # Split the key from the retrieved data, e.g., structure.mem.usages, where mem is the resource
            data[keys[1]][keys[0]][keys[1]][keys[2]] = usages[usage_metric]

        for rule in rules:
            try:
                # Check that the rule is active, the resource to watch is guarded and that the rule is activated
                if rule[&#34;active&#34;] and \
                        resources[rule[&#34;resource&#34;]][&#34;guard&#34;] and \
                        rule[&#34;generates&#34;] == &#34;events&#34; and \
                        jsonLogic(rule[&#34;rule&#34;], data[rule[&#34;resource&#34;]]):

                    event_name = MyUtils.generate_event_name(rule[&#34;action&#34;][&#34;events&#34;], rule[&#34;resource&#34;])
                    if event_name:
                        events.append(dict(
                            name=event_name,
                            resource=rule[&#34;resource&#34;],
                            type=&#34;event&#34;,
                            structure=structure_name,
                            action=rule[&#34;action&#34;],
                            timestamp=int(time.time()))
                        )
            except KeyError as e:
                MyUtils.log_warning(
                    &#34;rule: {0} is missing a parameter {1} {2}&#34;.format(rule[&#34;name&#34;],
                                                                      str(e), str(traceback.format_exc())), self.debug)

        return events

    def match_rules_and_events(self, structure, rules, events, limits, usages):
        generated_requests = list()
        events_to_remove = dict()
        for rule in rules:
            try:
                resource_label = rule[&#34;resource&#34;]
                if rule[&#34;active&#34;] and rule[&#34;generates&#34;] == &#34;requests&#34; and resource_label in events and jsonLogic(
                        rule[&#34;rule&#34;], events[resource_label]):

                    # If rescaling a container, check that the current resource value exists, otherwise there
                    # is nothing to rescale
                    if self.is_container(structure) and &#34;current&#34; not in structure[&#34;resources&#34;][resource_label]:
                        MyUtils.log_warning(
                            &#34;No current value for container&#39; {0}&#39; and resource &#39;{1}&#39;, can&#39;t rescale&#34;.format(
                                structure[&#34;name&#34;], resource_label), self.debug)
                        continue

                    # If no policy is set for scaling, default to &#34;fixed amount&#34;
                    if &#34;rescale_by&#34; not in rule.keys():
                        rule[&#34;rescale_by&#34;] = &#34;amount&#34;
                        MyUtils.log_warning(
                            &#34;No rescale_by policy is set in rule : &#39;{0}&#39;, falling back to default amount&#34;.format(
                                rule[&#34;name&#34;]), self.debug)

                    # Get the amount to be applied from the policy set
                    if rule[&#34;rescale_by&#34;] == &#34;amount&#34;:
                        amount = rule[&#34;amount&#34;]
                    elif rule[&#34;rescale_by&#34;] == &#34;percentage_reduction&#34;:
                        amount = self.get_amount_from_percentage_reduction(
                            structure, usages, resource_label, int(rule[&#34;percentage_reduction&#34;]))
                    elif rule[&#34;rescale_by&#34;] == &#34;fit_to_usage&#34;:
                        current_resource_limit = structure[&#34;resources&#34;][resource_label][&#34;current&#34;]
                        boundary = limits[resource_label][&#34;boundary&#34;]
                        usage = usages[translator_dict[resource_label]]
                        amount = self.get_amount_from_fit_reduction(current_resource_limit, boundary, usage)
                    elif rule[&#34;rescale_by&#34;] == &#34;proportional&#34; and rule[&#34;resource&#34;] == &#34;energy&#34;:
                        amount = self.get_amount_from_proportional_energy_rescaling(structure, resource_label)
                    else:
                        amount = rule[&#34;amount&#34;]

                    # If the resource is susceptible to check, ensure that it does not surpass any limit
                    if resource_label not in NON_ADJUSTABLE_RESOURCES:
                        structure_resources = structure[&#34;resources&#34;][resource_label]
                        structure_limits = limits[resource_label]
                        amount = self.adjust_amount(amount, structure_resources, structure_limits)

                    # Create the Request
                    request = dict(
                        type=&#34;request&#34;,
                        resource=resource_label,
                        amount=int(amount),
                        structure=structure[&#34;name&#34;],
                        action=MyUtils.generate_request_name(amount, resource_label),
                        timestamp=int(time.time()))

                    # For the moment, energy rescaling is uniquely mapped to cpu rescaling
                    if resource_label == &#34;energy&#34;:
                        request[&#34;resource&#34;] = &#34;cpu&#34;
                        request[&#34;for_energy&#34;] = True

                    # If scaling a container, add its host information as it will be needed
                    if self.is_container(structure):
                        request[&#34;host&#34;] = structure[&#34;host&#34;]
                        request[&#34;host_rescaler_ip&#34;] = structure[&#34;host_rescaler_ip&#34;]
                        request[&#34;host_rescaler_port&#34;] = structure[&#34;host_rescaler_port&#34;]

                    # Append the generated request
                    generated_requests.append(request)

                    # Remove the events that triggered the request
                    event_name = MyUtils.generate_event_name(events[resource_label][&#34;events&#34;], resource_label)
                    if event_name not in events_to_remove:
                        events_to_remove[event_name] = 0
                    events_to_remove[event_name] += rule[&#34;events_to_remove&#34;]

            except KeyError as e:
                MyUtils.log_warning(
                    &#34;rule: {0} is missing a parameter {1} {2} &#34;.format(rule[&#34;name&#34;], str(e),
                                                                       str(traceback.format_exc())), self.debug)

        return generated_requests, events_to_remove

    def print_structure_info(self, container, usages, limits, triggered_events, triggered_requests):
        resources = container[&#34;resources&#34;]

        container_name_str = &#34;@&#34; + container[&#34;name&#34;]
        container_guard_policy_str = &#34;with policy: {0}&#34;.format(container[&#34;guard_policy&#34;])
        resources_str = &#34;cpu({0}) - mem({1}) - energy({2})&#34;.format(
            self.get_resource_summary(&#34;cpu&#34;, resources, limits, usages),
            self.get_resource_summary(&#34;mem&#34;, resources, limits, usages),
            self.get_container_energy_str(resources))

        ev, req = list(), list()
        for event in triggered_events:
            ev.append(event[&#34;name&#34;])
        for request in triggered_requests:
            req.append(request[&#34;action&#34;])
        triggered_requests_and_events = &#34;#TRIGGERED EVENTS {0} AND TRIGGERED REQUESTS {1}&#34;.format(str(ev), str(req))
        MyUtils.log_info(
            &#34; &#34;.join([container_name_str, container_guard_policy_str, resources_str, triggered_requests_and_events]),
            self.debug)

    def process_serverless_structure(self, config, structure, usages, limits, rules):
        event_timeout = MyUtils.get_config_value(config, CONFIG_DEFAULT_VALUES, &#34;EVENT_TIMEOUT&#34;)

        # Match usages and rules to generate events
        triggered_events = self.match_usages_and_limits(structure[&#34;name&#34;], rules, usages, limits,
                                                        structure[&#34;resources&#34;])

        # Remote database operation
        self.couchdb_handler.add_events(triggered_events)

        # Remote database operation
        all_events = self.couchdb_handler.get_events(structure)

        # Filter the events according to timestamp
        filtered_events, old_events = self.sort_events(all_events, event_timeout)

        if old_events:
            # Remote database operation
            self.couchdb_handler.delete_events(old_events)

        # If there are no events, nothing else to do as no requests will be generated
        if filtered_events:
            # Merge all the event counts
            reduced_events = self.reduce_structure_events(filtered_events)

            # Match events and rules to generate requests
            triggered_requests, events_to_remove = self.match_rules_and_events(structure, rules, reduced_events, limits,
                                                                               usages)

            # Remove events that generated the request
            # Remote database operation
            for event in events_to_remove:
                self.couchdb_handler.delete_num_events_by_structure(structure, event, events_to_remove[event])

            if triggered_requests:
                # Remote database operation
                self.couchdb_handler.add_requests(triggered_requests)

        else:
            triggered_requests = list()

        # DEBUG AND INFO OUTPUT
        if self.debug:
            self.print_structure_info(structure, usages, limits, triggered_events, triggered_requests)

    def serverless(self, config, structure, rules):
        window_difference = MyUtils.get_config_value(config, CONFIG_DEFAULT_VALUES, &#34;WINDOW_TIMELAPSE&#34;)
        window_delay = MyUtils.get_config_value(config, CONFIG_DEFAULT_VALUES, &#34;WINDOW_DELAY&#34;)

        try:
            # Check if structure is guarded
            if &#34;guard&#34; not in structure or not structure[&#34;guard&#34;]:
                return

            # Check if structure is being monitored, otherwise, ignore
            try:
                metrics_to_retrieve = BDWATCHDOG_METRICS[structure[&#34;subtype&#34;]]
                metrics_to_generate = GUARDIAN_METRICS[structure[&#34;subtype&#34;]]
                tag = TAGS[structure[&#34;subtype&#34;]]
            except KeyError:
                # Default is container
                metrics_to_retrieve = BDWATCHDOG_CONTAINER_METRICS
                metrics_to_generate = GUARDIAN_CONTAINER_METRICS
                tag = &#34;host&#34;

            # Remote database operation
            usages = self.opentsdb_handler.get_structure_timeseries({tag: structure[&#34;name&#34;]}, window_difference,
                                                                    window_delay,
                                                                    metrics_to_retrieve, metrics_to_generate)

            # Skip this structure if all the usage metrics are unavailable
            if all([usages[metric] == self.NO_METRIC_DATA_DEFAULT_VALUE for metric in usages]):
                MyUtils.log_warning(&#34;structure: {0} has no usage data&#34;.format(structure[&#34;name&#34;]), self.debug)
                return

            resources = structure[&#34;resources&#34;]

            # Remote database operation
            limits = self.couchdb_handler.get_limits(structure)
            limits_resources = limits[&#34;resources&#34;]

            if not limits_resources:
                MyUtils.log_warning(&#34;structure: {0} has no limits&#34;.format(structure[&#34;name&#34;]), self.debug)
                return

            limits[&#34;resources&#34;] = self.adjust_container_state(resources, limits_resources)

            # Remote database operation
            self.couchdb_handler.update_limit(limits)

            self.process_serverless_structure(config, structure, usages, limits_resources, rules)

        except Exception as e:
            MyUtils.log_error(
                &#34;error with structure: {0} {1} {2}&#34;.format(structure[&#34;name&#34;], str(e), str(traceback.format_exc())),
                self.debug)

    def process_fixed_resources_structure(self, resources, structure):
        triggered_requests = list()
        for resource in resources:
            if not resources[resource][&#34;guard&#34;]:
                continue

            if &#34;fixed&#34; in structure[&#34;resources&#34;][resource] and &#34;current&#34; in structure[&#34;resources&#34;][resource]:
                fixed_value = structure[&#34;resources&#34;][resource][&#34;fixed&#34;]
                current_value = structure[&#34;resources&#34;][resource][&#34;current&#34;]
                if fixed_value != current_value:
                    amount = fixed_value - current_value
                    request = dict(
                        type=&#34;request&#34;,
                        resource=resource,
                        amount=int(amount),
                        structure=structure[&#34;name&#34;],
                        action=MyUtils.generate_request_name(amount, resource),
                        timestamp=int(time.time()))

                    if self.is_container(structure):
                        request[&#34;host&#34;] = structure[&#34;host&#34;]
                        request[&#34;host_rescaler_ip&#34;] = structure[&#34;host_rescaler_ip&#34;]
                        request[&#34;host_rescaler_port&#34;] = structure[&#34;host_rescaler_port&#34;]

                    # Remote database operation
                    self.couchdb_handler.add_request(request)
                    triggered_requests.append(request)
            else:
                MyUtils.log_warning(
                    &#34;structure: {0} has no &#39;current&#39; or &#39;fixed&#39; value for resource: {1}&#34;.format(
                        structure[&#34;name&#34;], resource), self.debug)

        # DEBUG AND INFO OUTPUT
        if self.debug:
            self.print_structure_info(structure, {}, {}, [], triggered_requests)

    def fixed_resource_amount(self, structure):
        try:
            # Check if structure is guarded
            if &#34;guard&#34; not in structure or not structure[&#34;guard&#34;]:
                return

            self.process_fixed_resources_structure(structure[&#34;resources&#34;], structure)

        except Exception as e:
            MyUtils.log_error(
                &#34;error with structure: {0} {1} {2}&#34;.format(structure[&#34;name&#34;], str(e), str(traceback.format_exc())),
                self.debug)

    def guard_structures(self, config, structures):
        # Remote database operation
        rules = self.couchdb_handler.get_rules()

        for structure in structures:
            if &#34;guard_policy&#34; not in structure:
                # Default option will be serverless
                self.serverless(config, structure, rules)
            else:
                if structure[&#34;guard_policy&#34;] == &#34;serverless&#34;:
                    self.serverless(config, structure, rules)
                elif structure[&#34;guard_policy&#34;] == &#34;fixed&#34;:
                    self.fixed_resource_amount(structure)
                else:
                    self.serverless(config, structure, rules)

    def guard(self, ):
        logging.basicConfig(filename=SERVICE_NAME + &#39;.log&#39;, level=logging.INFO)
        while True:

            # Get service info
            service = MyUtils.get_service(self.couchdb_handler, SERVICE_NAME)

            # Heartbeat
            MyUtils.beat(self.couchdb_handler, SERVICE_NAME)

            # CONFIG
            config = service[&#34;config&#34;]
            self.debug = MyUtils.get_config_value(config, CONFIG_DEFAULT_VALUES, &#34;DEBUG&#34;)
            window_difference = MyUtils.get_config_value(config, CONFIG_DEFAULT_VALUES, &#34;WINDOW_TIMELAPSE&#34;)
            structure_guarded = MyUtils.get_config_value(config, CONFIG_DEFAULT_VALUES, &#34;STRUCTURE_GUARDED&#34;)
            thread = None

            # Remote database operation
            structures = MyUtils.get_structures(self.couchdb_handler, self.debug, subtype=structure_guarded)
            if structures:
                thread = Thread(target=self.guard_structures, args=(config, structures,))
                thread.start()

            MyUtils.log_info(
                &#34;Epoch processed at {0}&#34;.format(MyUtils.get_time_now_string()), self.debug)
            time.sleep(window_difference)

            if thread and thread.isAlive():
                delay_start = time.time()
                MyUtils.log_warning(
                    &#34;Previous thread didn&#39;t finish before next poll is due, with window time of &#34; +
                    &#34;{0} seconds, at {1}&#34;.format(str(window_difference), MyUtils.get_time_now_string()), self.debug)
                MyUtils.log_warning(&#34;Going to wait until thread finishes before proceeding&#34;, self.debug)
                thread.join()
                delay_end = time.time()
                MyUtils.log_warning(&#34;Resulting delay of: {0} seconds&#34;.format(str(delay_end - delay_start)),
                                    self.debug)


def main():
    try:
        guardian = Guardian()
        guardian.guard()
    except Exception as e:
        MyUtils.log_error(&#34;{0} {1}&#34;.format(str(e), str(traceback.format_exc())), debug=True)


if __name__ == &#34;__main__&#34;:
    main()}</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="src.Guardian.Guardian.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def main():
    try:
        guardian = Guardian()
        guardian.guard()
    except Exception as e:
        MyUtils.log_error(&#34;{0} {1}&#34;.format(str(e), str(traceback.format_exc())), debug=True)}</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.Guardian.Guardian.Guardian"><code class="flex name class">
<span>class <span class="ident">Guardian</span></span>
</code></dt>
<dd>
<section class="desc"><p>Guardian class that implements all the logic for this service</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Guardian:
    &#34;&#34;&#34; Guardian class that implements all the logic for this service&#34;&#34;&#34;

    def __init__(self):
        self.opentsdb_handler = bdwatchdog.OpenTSDBServer()
        self.couchdb_handler = couchdb.CouchDBServer()
        self.NO_METRIC_DATA_DEFAULT_VALUE = self.opentsdb_handler.NO_METRIC_DATA_DEFAULT_VALUE
        self.guardable_resources = [&#39;cpu&#39;, &#39;mem&#39;, &#39;energy&#39;]
        self.debug = True

    @staticmethod
    def check_unset_values(value, label):
        if value == NOT_AVAILABLE_STRING:
            raise ValueError(&#34;value for &#39;{0}&#39; is not set or is not available.&#34;.format(label))

    @staticmethod
    def check_invalid_values(value1, label1, value2, label2, resource=&#34;n/a&#34;):
        if value1 &gt; value2:
            raise ValueError(&#34;in resources: {0} value for &#39;{1}&#39;: {2} is greater than value for &#39;{3}&#39;: {4}&#34;.format(
                resource, label1, str(value1), label2, str(value2)))

    @staticmethod
    def try_get_value(d, key):
        &#34;&#34;&#34;
        Parameters:
            d : dict -&gt; A dictionary with strings as keys
            key : string -&gt; A string used as key for a dictionary of integers

        Returns:
            The value stored in the dictionary or a specific value if it is not in it or if it is not an valid integer
        &#34;&#34;&#34;
        try:
            return int(d[key])
        except (KeyError, ValueError):
            return NOT_AVAILABLE_STRING

    @staticmethod
    def is_application(structure):
        return structure[&#34;subtype&#34;] == &#34;application&#34;

    @staticmethod
    def is_container(structure):
        return structure[&#34;subtype&#34;] == &#34;container&#34;

    @staticmethod
    def sort_events(structure_events, event_timeout):
        &#34;&#34;&#34;
        Parameters:
            structure_events : list -&gt; A list of the events triggered in the past for a specific structure
            event_timeout : integer -&gt; A timeout in seconds

        Returns:
            A tuple of lists of events that either fall in the time window between
            (now - timeout) and (now), the valid events, or outside of it, the invalid ones.
        &#34;&#34;&#34;
        valid, invalid = list(), list()
        for event in structure_events:
            if event[&#34;timestamp&#34;] &lt; time.time() - event_timeout:
                invalid.append(event)
            else:
                valid.append(event)
        return valid, invalid

    @staticmethod
    def reduce_structure_events(structure_events):
        &#34;&#34;&#34;
        Parameters:
            structure_events : list -&gt;

        Returns:
            A dictionary with the added up events in a signle dictionary
        &#34;&#34;&#34;
        events_reduced = {&#34;action&#34;: {}}
        for event in structure_events:
            resource = event[&#34;resource&#34;]
            if resource not in events_reduced[&#34;action&#34;]:
                events_reduced[&#34;action&#34;][resource] = {&#34;events&#34;: {&#34;scale&#34;: {&#34;down&#34;: 0, &#34;up&#34;: 0}}}
            for key in event[&#34;action&#34;][&#34;events&#34;][&#34;scale&#34;].keys():
                value = event[&#34;action&#34;][&#34;events&#34;][&#34;scale&#34;][key]
                events_reduced[&#34;action&#34;][resource][&#34;events&#34;][&#34;scale&#34;][key] += value
        return events_reduced[&#34;action&#34;]

    def get_resource_summary(self, resource_label, resources_dict, limits_dict, usages_dict):
        &#34;&#34;&#34;
        Parameters:
            resource_label : string -&gt; the name of the resource to access the dictionaries
            resources_dict : dict -&gt; a dictionary with the metrics (e.g., max, min) of the resources
            limits_dict : dict -&gt; a dictionary with the limits (e.g., lower, upper) of the resources
            usages_dict : dict -&gt; a dictionary with the usages of the resources

        Returns:
            A string that summarizes the state of a resource in terms of its metrics
        &#34;&#34;&#34;
        metrics = resources_dict[resource_label]
        limits = limits_dict[resource_label]

        if not usages_dict or usages_dict[translator_dict[resource_label]] == self.NO_METRIC_DATA_DEFAULT_VALUE:
            usage_value_string = NOT_AVAILABLE_STRING
        else:
            usage_value_string = str(&#34;%.2f&#34; % usages_dict[translator_dict[resource_label]])

        strings = list()
        if not limits_dict and not usages_dict:
            for field in [&#34;max&#34;, &#34;current&#34;, &#34;max&#34;, &#34;min&#34;]:
                strings.append(str(self.try_get_value(metrics, field)))
        else:
            for field in [(&#34;max&#34;, metrics), (&#34;current&#34;, metrics), (&#34;upper&#34;, limits), (&#34;lower&#34;, limits),
                          (&#34;min&#34;, metrics)]:
                strings.append(str(self.try_get_value(field[1], field[0])))
            strings.insert(3, usage_value_string)  # Manually add the usage metric

        return &#34;,&#34;.join(strings)

    @staticmethod
    def adjust_amount(amount, structure_resources, structure_limits):
        &#34;&#34;&#34;
        Parameters:
            * **amount** : *integer* -&gt; a number representing the amount to reduce or increase from the current value
            * **structure_resources** : *dict* -&gt; asdf
            * **structure_limits** : *dict* -&gt; asdf

        Returns:
            The amount adjusted (trimmed) in case it would exceed any limit
        &#34;&#34;&#34;
        expected_value = structure_resources[&#34;current&#34;] + amount
        lower_limit = structure_limits[&#34;lower&#34;] + amount
        max_limit = structure_resources[&#34;max&#34;]
        min_limit = structure_resources[&#34;min&#34;]

        if lower_limit &lt; min_limit:
            # The amount to reduce is too big, adjust it so that the lower limit is set to the minimum
            amount += (min_limit - lower_limit)
        elif expected_value &gt; max_limit:
            # The amount to increase is too big, adjust it so that the current limit is set to the maximum
            amount -= (expected_value - max_limit)

        return amount

    @staticmethod
    def get_amount_from_percentage_reduction(structure, usages, resource, percentage_reduction):
        current_resource_limit = structure[&#34;resources&#34;][resource][&#34;current&#34;]
        current_resource_usage = usages[translator_dict[resource]]
        difference = current_resource_limit - current_resource_usage
        if percentage_reduction &gt; MAX_PERCENTAGE_REDUCTION_ALLOWED:
            percentage_reduction = MAX_PERCENTAGE_REDUCTION_ALLOWED
        amount = int(-1 * (percentage_reduction * difference) / 100)
        return amount

    @staticmethod
    def get_amount_from_fit_reduction(current_resource_limit, boundary, current_resource_usage):
        &#34;&#34;&#34;
        Parameters:
            current_resource_limit : integer -&gt;
            boundary : integer -&gt;
            current_resource_usage : integer -&gt;

        Returns:
            The amount to be reduced from the fit to usage policy.
        &#34;&#34;&#34;
        upper_to_lower_window = boundary
        current_to_upper_window = boundary

        # Set the limit so that the resource usage is placed in between the upper and lower limits
        # and keeping the boundary between the upper and the real resource limits
        desired_applied_resource_limit = \
            current_resource_usage + int(upper_to_lower_window / 2) + current_to_upper_window

        return -1 * (current_resource_limit - desired_applied_resource_limit)

    @staticmethod
    def get_amount_from_proportional_energy_rescaling(structure, resource):
        max_resource_limit = structure[&#34;resources&#34;][resource][&#34;max&#34;]
        current_resource_limit = structure[&#34;resources&#34;][resource][&#34;usage&#34;]
        difference = max_resource_limit - current_resource_limit
        energy_aplification = CPU_SHARES_PER_WATT  # How many cpu shares to rescale per watt
        return int(difference * energy_aplification)

    def get_container_energy_str(self, resources_dict):
        &#34;&#34;&#34;
        Parameters:
            resources_dict : dict -&gt; A dictionary with all the resources&#39; information

        Returns:
            A string that summarizes the state of the enery resource
        &#34;&#34;&#34;
        energy_dict = resources_dict[&#34;energy&#34;]
        string = list()
        for field in [&#34;max&#34;, &#34;usage&#34;, &#34;min&#34;]:
            string.append(str(self.try_get_value(energy_dict, field)))
        return &#34;,&#34;.join(string)

    def adjust_container_state(self, resources, limits):
        for resource in [&#34;cpu&#34;, &#34;mem&#34;]:
            errors = True
            while errors:
                try:
                    self.check_invalid_container_state(resources, limits, resource)
                    errors = False
                except ValueError:
                    # Correct the chain current &gt; upper &gt; lower, including boundary between current and upper
                    boundary = limits[resource][&#34;boundary&#34;]
                    limits[resource][&#34;upper&#34;] = resources[resource][&#34;current&#34;] - boundary
                    limits[resource][&#34;lower&#34;] = max(limits[resource][&#34;upper&#34;] - boundary, resources[resource][&#34;min&#34;])
        return limits

    def check_invalid_container_state(self, resources, limits, resource):
        data = {&#34;res&#34;: resources, &#34;lim&#34;: limits}
        values_tuples = [(&#34;max&#34;, &#34;res&#34;), (&#34;current&#34;, &#34;res&#34;), (&#34;upper&#34;, &#34;lim&#34;), (&#34;lower&#34;, &#34;lim&#34;), (&#34;min&#34;, &#34;res&#34;)]
        values = dict()
        for value, vtype in values_tuples:
            values[value] = self.try_get_value(data[vtype][resource], value)
        values[&#34;boundary&#34;] = data[&#34;lim&#34;][resource][&#34;boundary&#34;]

        # Check values are set and valid, except for current as it may have not been persisted yet
        for value in values:
            self.check_unset_values(values[value], value)

        # Check if the first value is greater than the second
        # check the full chain &#34;max &gt; upper &gt; current &gt; lower &gt; min&#34;
        if values[&#34;current&#34;] != NOT_AVAILABLE_STRING:
            self.check_invalid_values(values[&#34;current&#34;], &#34;current&#34;, values[&#34;max&#34;], &#34;max&#34;)
        self.check_invalid_values(values[&#34;upper&#34;], &#34;upper&#34;, values[&#34;current&#34;], &#34;current&#34;, resource=resource)
        self.check_invalid_values(values[&#34;lower&#34;], &#34;lower&#34;, values[&#34;upper&#34;], &#34;upper&#34;, resource=resource)
        self.check_invalid_values(values[&#34;min&#34;], &#34;min&#34;, values[&#34;lower&#34;], &#34;lower&#34;, resource=resource)

        # Check that there is a boundary between values, like the current and upper, so
        # that the limit can be surpassed
        if values[&#34;current&#34;] != NOT_AVAILABLE_STRING:
            if values[&#34;current&#34;] - values[&#34;boundary&#34;] &lt; values[&#34;upper&#34;]:
                raise ValueError(
                    &#34;value for &#39;current&#39;: {0} is too close (less than {1}) to value for &#39;upper&#39;: {2}&#34;.format(
                        str(values[&#34;current&#34;]), str(values[&#34;boundary&#34;]), str(values[&#34;upper&#34;])))

            elif values[&#34;current&#34;] - values[&#34;boundary&#34;] &gt; values[&#34;upper&#34;]:
                raise ValueError(
                    &#34;value for &#39;current&#39;: {0} is too far (more than {1}) from value for &#39;upper&#39;: {2}&#34;.format(
                        str(values[&#34;current&#34;]), str(values[&#34;boundary&#34;]), str(values[&#34;upper&#34;])))

    def match_usages_and_limits(self, structure_name, rules, usages, limits, resources):
        events = []
        data = dict()

        for resource in self.guardable_resources:
            if resource in resources:
                data[resource] = {
                    &#34;limits&#34;: {resource: limits[resource]},
                    &#34;structure&#34;: {resource: resources[resource]}}

        for usage_metric in usages:
            keys = usage_metric.split(&#34;.&#34;)
            # Split the key from the retrieved data, e.g., structure.mem.usages, where mem is the resource
            data[keys[1]][keys[0]][keys[1]][keys[2]] = usages[usage_metric]

        for rule in rules:
            try:
                # Check that the rule is active, the resource to watch is guarded and that the rule is activated
                if rule[&#34;active&#34;] and \
                        resources[rule[&#34;resource&#34;]][&#34;guard&#34;] and \
                        rule[&#34;generates&#34;] == &#34;events&#34; and \
                        jsonLogic(rule[&#34;rule&#34;], data[rule[&#34;resource&#34;]]):

                    event_name = MyUtils.generate_event_name(rule[&#34;action&#34;][&#34;events&#34;], rule[&#34;resource&#34;])
                    if event_name:
                        events.append(dict(
                            name=event_name,
                            resource=rule[&#34;resource&#34;],
                            type=&#34;event&#34;,
                            structure=structure_name,
                            action=rule[&#34;action&#34;],
                            timestamp=int(time.time()))
                        )
            except KeyError as e:
                MyUtils.log_warning(
                    &#34;rule: {0} is missing a parameter {1} {2}&#34;.format(rule[&#34;name&#34;],
                                                                      str(e), str(traceback.format_exc())), self.debug)

        return events

    def match_rules_and_events(self, structure, rules, events, limits, usages):
        generated_requests = list()
        events_to_remove = dict()
        for rule in rules:
            try:
                resource_label = rule[&#34;resource&#34;]
                if rule[&#34;active&#34;] and rule[&#34;generates&#34;] == &#34;requests&#34; and resource_label in events and jsonLogic(
                        rule[&#34;rule&#34;], events[resource_label]):

                    # If rescaling a container, check that the current resource value exists, otherwise there
                    # is nothing to rescale
                    if self.is_container(structure) and &#34;current&#34; not in structure[&#34;resources&#34;][resource_label]:
                        MyUtils.log_warning(
                            &#34;No current value for container&#39; {0}&#39; and resource &#39;{1}&#39;, can&#39;t rescale&#34;.format(
                                structure[&#34;name&#34;], resource_label), self.debug)
                        continue

                    # If no policy is set for scaling, default to &#34;fixed amount&#34;
                    if &#34;rescale_by&#34; not in rule.keys():
                        rule[&#34;rescale_by&#34;] = &#34;amount&#34;
                        MyUtils.log_warning(
                            &#34;No rescale_by policy is set in rule : &#39;{0}&#39;, falling back to default amount&#34;.format(
                                rule[&#34;name&#34;]), self.debug)

                    # Get the amount to be applied from the policy set
                    if rule[&#34;rescale_by&#34;] == &#34;amount&#34;:
                        amount = rule[&#34;amount&#34;]
                    elif rule[&#34;rescale_by&#34;] == &#34;percentage_reduction&#34;:
                        amount = self.get_amount_from_percentage_reduction(
                            structure, usages, resource_label, int(rule[&#34;percentage_reduction&#34;]))
                    elif rule[&#34;rescale_by&#34;] == &#34;fit_to_usage&#34;:
                        current_resource_limit = structure[&#34;resources&#34;][resource_label][&#34;current&#34;]
                        boundary = limits[resource_label][&#34;boundary&#34;]
                        usage = usages[translator_dict[resource_label]]
                        amount = self.get_amount_from_fit_reduction(current_resource_limit, boundary, usage)
                    elif rule[&#34;rescale_by&#34;] == &#34;proportional&#34; and rule[&#34;resource&#34;] == &#34;energy&#34;:
                        amount = self.get_amount_from_proportional_energy_rescaling(structure, resource_label)
                    else:
                        amount = rule[&#34;amount&#34;]

                    # If the resource is susceptible to check, ensure that it does not surpass any limit
                    if resource_label not in NON_ADJUSTABLE_RESOURCES:
                        structure_resources = structure[&#34;resources&#34;][resource_label]
                        structure_limits = limits[resource_label]
                        amount = self.adjust_amount(amount, structure_resources, structure_limits)

                    # Create the Request
                    request = dict(
                        type=&#34;request&#34;,
                        resource=resource_label,
                        amount=int(amount),
                        structure=structure[&#34;name&#34;],
                        action=MyUtils.generate_request_name(amount, resource_label),
                        timestamp=int(time.time()))

                    # For the moment, energy rescaling is uniquely mapped to cpu rescaling
                    if resource_label == &#34;energy&#34;:
                        request[&#34;resource&#34;] = &#34;cpu&#34;
                        request[&#34;for_energy&#34;] = True

                    # If scaling a container, add its host information as it will be needed
                    if self.is_container(structure):
                        request[&#34;host&#34;] = structure[&#34;host&#34;]
                        request[&#34;host_rescaler_ip&#34;] = structure[&#34;host_rescaler_ip&#34;]
                        request[&#34;host_rescaler_port&#34;] = structure[&#34;host_rescaler_port&#34;]

                    # Append the generated request
                    generated_requests.append(request)

                    # Remove the events that triggered the request
                    event_name = MyUtils.generate_event_name(events[resource_label][&#34;events&#34;], resource_label)
                    if event_name not in events_to_remove:
                        events_to_remove[event_name] = 0
                    events_to_remove[event_name] += rule[&#34;events_to_remove&#34;]

            except KeyError as e:
                MyUtils.log_warning(
                    &#34;rule: {0} is missing a parameter {1} {2} &#34;.format(rule[&#34;name&#34;], str(e),
                                                                       str(traceback.format_exc())), self.debug)

        return generated_requests, events_to_remove

    def print_structure_info(self, container, usages, limits, triggered_events, triggered_requests):
        resources = container[&#34;resources&#34;]

        container_name_str = &#34;@&#34; + container[&#34;name&#34;]
        container_guard_policy_str = &#34;with policy: {0}&#34;.format(container[&#34;guard_policy&#34;])
        resources_str = &#34;cpu({0}) - mem({1}) - energy({2})&#34;.format(
            self.get_resource_summary(&#34;cpu&#34;, resources, limits, usages),
            self.get_resource_summary(&#34;mem&#34;, resources, limits, usages),
            self.get_container_energy_str(resources))

        ev, req = list(), list()
        for event in triggered_events:
            ev.append(event[&#34;name&#34;])
        for request in triggered_requests:
            req.append(request[&#34;action&#34;])
        triggered_requests_and_events = &#34;#TRIGGERED EVENTS {0} AND TRIGGERED REQUESTS {1}&#34;.format(str(ev), str(req))
        MyUtils.log_info(
            &#34; &#34;.join([container_name_str, container_guard_policy_str, resources_str, triggered_requests_and_events]),
            self.debug)

    def process_serverless_structure(self, config, structure, usages, limits, rules):
        event_timeout = MyUtils.get_config_value(config, CONFIG_DEFAULT_VALUES, &#34;EVENT_TIMEOUT&#34;)

        # Match usages and rules to generate events
        triggered_events = self.match_usages_and_limits(structure[&#34;name&#34;], rules, usages, limits,
                                                        structure[&#34;resources&#34;])

        # Remote database operation
        self.couchdb_handler.add_events(triggered_events)

        # Remote database operation
        all_events = self.couchdb_handler.get_events(structure)

        # Filter the events according to timestamp
        filtered_events, old_events = self.sort_events(all_events, event_timeout)

        if old_events:
            # Remote database operation
            self.couchdb_handler.delete_events(old_events)

        # If there are no events, nothing else to do as no requests will be generated
        if filtered_events:
            # Merge all the event counts
            reduced_events = self.reduce_structure_events(filtered_events)

            # Match events and rules to generate requests
            triggered_requests, events_to_remove = self.match_rules_and_events(structure, rules, reduced_events, limits,
                                                                               usages)

            # Remove events that generated the request
            # Remote database operation
            for event in events_to_remove:
                self.couchdb_handler.delete_num_events_by_structure(structure, event, events_to_remove[event])

            if triggered_requests:
                # Remote database operation
                self.couchdb_handler.add_requests(triggered_requests)

        else:
            triggered_requests = list()

        # DEBUG AND INFO OUTPUT
        if self.debug:
            self.print_structure_info(structure, usages, limits, triggered_events, triggered_requests)

    def serverless(self, config, structure, rules):
        window_difference = MyUtils.get_config_value(config, CONFIG_DEFAULT_VALUES, &#34;WINDOW_TIMELAPSE&#34;)
        window_delay = MyUtils.get_config_value(config, CONFIG_DEFAULT_VALUES, &#34;WINDOW_DELAY&#34;)

        try:
            # Check if structure is guarded
            if &#34;guard&#34; not in structure or not structure[&#34;guard&#34;]:
                return

            # Check if structure is being monitored, otherwise, ignore
            try:
                metrics_to_retrieve = BDWATCHDOG_METRICS[structure[&#34;subtype&#34;]]
                metrics_to_generate = GUARDIAN_METRICS[structure[&#34;subtype&#34;]]
                tag = TAGS[structure[&#34;subtype&#34;]]
            except KeyError:
                # Default is container
                metrics_to_retrieve = BDWATCHDOG_CONTAINER_METRICS
                metrics_to_generate = GUARDIAN_CONTAINER_METRICS
                tag = &#34;host&#34;

            # Remote database operation
            usages = self.opentsdb_handler.get_structure_timeseries({tag: structure[&#34;name&#34;]}, window_difference,
                                                                    window_delay,
                                                                    metrics_to_retrieve, metrics_to_generate)

            # Skip this structure if all the usage metrics are unavailable
            if all([usages[metric] == self.NO_METRIC_DATA_DEFAULT_VALUE for metric in usages]):
                MyUtils.log_warning(&#34;structure: {0} has no usage data&#34;.format(structure[&#34;name&#34;]), self.debug)
                return

            resources = structure[&#34;resources&#34;]

            # Remote database operation
            limits = self.couchdb_handler.get_limits(structure)
            limits_resources = limits[&#34;resources&#34;]

            if not limits_resources:
                MyUtils.log_warning(&#34;structure: {0} has no limits&#34;.format(structure[&#34;name&#34;]), self.debug)
                return

            limits[&#34;resources&#34;] = self.adjust_container_state(resources, limits_resources)

            # Remote database operation
            self.couchdb_handler.update_limit(limits)

            self.process_serverless_structure(config, structure, usages, limits_resources, rules)

        except Exception as e:
            MyUtils.log_error(
                &#34;error with structure: {0} {1} {2}&#34;.format(structure[&#34;name&#34;], str(e), str(traceback.format_exc())),
                self.debug)

    def process_fixed_resources_structure(self, resources, structure):
        triggered_requests = list()
        for resource in resources:
            if not resources[resource][&#34;guard&#34;]:
                continue

            if &#34;fixed&#34; in structure[&#34;resources&#34;][resource] and &#34;current&#34; in structure[&#34;resources&#34;][resource]:
                fixed_value = structure[&#34;resources&#34;][resource][&#34;fixed&#34;]
                current_value = structure[&#34;resources&#34;][resource][&#34;current&#34;]
                if fixed_value != current_value:
                    amount = fixed_value - current_value
                    request = dict(
                        type=&#34;request&#34;,
                        resource=resource,
                        amount=int(amount),
                        structure=structure[&#34;name&#34;],
                        action=MyUtils.generate_request_name(amount, resource),
                        timestamp=int(time.time()))

                    if self.is_container(structure):
                        request[&#34;host&#34;] = structure[&#34;host&#34;]
                        request[&#34;host_rescaler_ip&#34;] = structure[&#34;host_rescaler_ip&#34;]
                        request[&#34;host_rescaler_port&#34;] = structure[&#34;host_rescaler_port&#34;]

                    # Remote database operation
                    self.couchdb_handler.add_request(request)
                    triggered_requests.append(request)
            else:
                MyUtils.log_warning(
                    &#34;structure: {0} has no &#39;current&#39; or &#39;fixed&#39; value for resource: {1}&#34;.format(
                        structure[&#34;name&#34;], resource), self.debug)

        # DEBUG AND INFO OUTPUT
        if self.debug:
            self.print_structure_info(structure, {}, {}, [], triggered_requests)

    def fixed_resource_amount(self, structure):
        try:
            # Check if structure is guarded
            if &#34;guard&#34; not in structure or not structure[&#34;guard&#34;]:
                return

            self.process_fixed_resources_structure(structure[&#34;resources&#34;], structure)

        except Exception as e:
            MyUtils.log_error(
                &#34;error with structure: {0} {1} {2}&#34;.format(structure[&#34;name&#34;], str(e), str(traceback.format_exc())),
                self.debug)

    def guard_structures(self, config, structures):
        # Remote database operation
        rules = self.couchdb_handler.get_rules()

        for structure in structures:
            if &#34;guard_policy&#34; not in structure:
                # Default option will be serverless
                self.serverless(config, structure, rules)
            else:
                if structure[&#34;guard_policy&#34;] == &#34;serverless&#34;:
                    self.serverless(config, structure, rules)
                elif structure[&#34;guard_policy&#34;] == &#34;fixed&#34;:
                    self.fixed_resource_amount(structure)
                else:
                    self.serverless(config, structure, rules)

    def guard(self, ):
        logging.basicConfig(filename=SERVICE_NAME + &#39;.log&#39;, level=logging.INFO)
        while True:

            # Get service info
            service = MyUtils.get_service(self.couchdb_handler, SERVICE_NAME)

            # Heartbeat
            MyUtils.beat(self.couchdb_handler, SERVICE_NAME)

            # CONFIG
            config = service[&#34;config&#34;]
            self.debug = MyUtils.get_config_value(config, CONFIG_DEFAULT_VALUES, &#34;DEBUG&#34;)
            window_difference = MyUtils.get_config_value(config, CONFIG_DEFAULT_VALUES, &#34;WINDOW_TIMELAPSE&#34;)
            structure_guarded = MyUtils.get_config_value(config, CONFIG_DEFAULT_VALUES, &#34;STRUCTURE_GUARDED&#34;)
            thread = None

            # Remote database operation
            structures = MyUtils.get_structures(self.couchdb_handler, self.debug, subtype=structure_guarded)
            if structures:
                thread = Thread(target=self.guard_structures, args=(config, structures,))
                thread.start()

            MyUtils.log_info(
                &#34;Epoch processed at {0}&#34;.format(MyUtils.get_time_now_string()), self.debug)
            time.sleep(window_difference)

            if thread and thread.isAlive():
                delay_start = time.time()
                MyUtils.log_warning(
                    &#34;Previous thread didn&#39;t finish before next poll is due, with window time of &#34; +
                    &#34;{0} seconds, at {1}&#34;.format(str(window_difference), MyUtils.get_time_now_string()), self.debug)
                MyUtils.log_warning(&#34;Going to wait until thread finishes before proceeding&#34;, self.debug)
                thread.join()
                delay_end = time.time()
                MyUtils.log_warning(&#34;Resulting delay of: {0} seconds&#34;.format(str(delay_end - delay_start)),
                                    self.debug)}</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="src.Guardian.Guardian.Guardian.adjust_amount"><code class="name flex">
<span>def <span class="ident">adjust_amount</span></span>(<span>amount, structure_resources, structure_limits)</span>
</code></dt>
<dd>
<section class="desc"><dl>
<dt><strong><code>Parameters</code></strong></dt>
<dd>
<ul>
<li><strong>amount</strong> : <em>integer</em> -&gt; a number representing the amount to reduce or increase from the current value</li>
<li><strong>structure_resources</strong> : <em>dict</em> -&gt; asdf</li>
<li><strong>structure_limits</strong> : <em>dict</em> -&gt; asdf</li>
</ul>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The amount adjusted (trimmed) in case it would exceed any limit</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@staticmethod
def adjust_amount(amount, structure_resources, structure_limits):
    &#34;&#34;&#34;
    Parameters:
        * **amount** : *integer* -&gt; a number representing the amount to reduce or increase from the current value
        * **structure_resources** : *dict* -&gt; asdf
        * **structure_limits** : *dict* -&gt; asdf

    Returns:
        The amount adjusted (trimmed) in case it would exceed any limit
    &#34;&#34;&#34;
    expected_value = structure_resources[&#34;current&#34;] + amount
    lower_limit = structure_limits[&#34;lower&#34;] + amount
    max_limit = structure_resources[&#34;max&#34;]
    min_limit = structure_resources[&#34;min&#34;]

    if lower_limit &lt; min_limit:
        # The amount to reduce is too big, adjust it so that the lower limit is set to the minimum
        amount += (min_limit - lower_limit)
    elif expected_value &gt; max_limit:
        # The amount to increase is too big, adjust it so that the current limit is set to the maximum
        amount -= (expected_value - max_limit)

    return amount}</code></pre>
</details>
</dd>
<dt id="src.Guardian.Guardian.Guardian.check_invalid_values"><code class="name flex">
<span>def <span class="ident">check_invalid_values</span></span>(<span>value1, label1, value2, label2, resource=&#39;n/a&#39;)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@staticmethod
def check_invalid_values(value1, label1, value2, label2, resource=&#34;n/a&#34;):
    if value1 &gt; value2:
        raise ValueError(&#34;in resources: {0} value for &#39;{1}&#39;: {2} is greater than value for &#39;{3}&#39;: {4}&#34;.format(
            resource, label1, str(value1), label2, str(value2)))}</code></pre>
</details>
</dd>
<dt id="src.Guardian.Guardian.Guardian.check_unset_values"><code class="name flex">
<span>def <span class="ident">check_unset_values</span></span>(<span>value, label)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@staticmethod
def check_unset_values(value, label):
    if value == NOT_AVAILABLE_STRING:
        raise ValueError(&#34;value for &#39;{0}&#39; is not set or is not available.&#34;.format(label))}</code></pre>
</details>
</dd>
<dt id="src.Guardian.Guardian.Guardian.get_amount_from_fit_reduction"><code class="name flex">
<span>def <span class="ident">get_amount_from_fit_reduction</span></span>(<span>current_resource_limit, boundary, current_resource_usage)</span>
</code></dt>
<dd>
<section class="desc"><dl>
<dt><strong><code>Parameters</code></strong></dt>
<dd>current_resource_limit : integer -&gt;
boundary : integer -&gt;
current_resource_usage : integer -&gt;</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The amount to be reduced from the fit to usage policy.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@staticmethod
def get_amount_from_fit_reduction(current_resource_limit, boundary, current_resource_usage):
    &#34;&#34;&#34;
    Parameters:
        current_resource_limit : integer -&gt;
        boundary : integer -&gt;
        current_resource_usage : integer -&gt;

    Returns:
        The amount to be reduced from the fit to usage policy.
    &#34;&#34;&#34;
    upper_to_lower_window = boundary
    current_to_upper_window = boundary

    # Set the limit so that the resource usage is placed in between the upper and lower limits
    # and keeping the boundary between the upper and the real resource limits
    desired_applied_resource_limit = \
        current_resource_usage + int(upper_to_lower_window / 2) + current_to_upper_window

    return -1 * (current_resource_limit - desired_applied_resource_limit)}</code></pre>
</details>
</dd>
<dt id="src.Guardian.Guardian.Guardian.get_amount_from_percentage_reduction"><code class="name flex">
<span>def <span class="ident">get_amount_from_percentage_reduction</span></span>(<span>structure, usages, resource, percentage_reduction)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@staticmethod
def get_amount_from_percentage_reduction(structure, usages, resource, percentage_reduction):
    current_resource_limit = structure[&#34;resources&#34;][resource][&#34;current&#34;]
    current_resource_usage = usages[translator_dict[resource]]
    difference = current_resource_limit - current_resource_usage
    if percentage_reduction &gt; MAX_PERCENTAGE_REDUCTION_ALLOWED:
        percentage_reduction = MAX_PERCENTAGE_REDUCTION_ALLOWED
    amount = int(-1 * (percentage_reduction * difference) / 100)
    return amount}</code></pre>
</details>
</dd>
<dt id="src.Guardian.Guardian.Guardian.get_amount_from_proportional_energy_rescaling"><code class="name flex">
<span>def <span class="ident">get_amount_from_proportional_energy_rescaling</span></span>(<span>structure, resource)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@staticmethod
def get_amount_from_proportional_energy_rescaling(structure, resource):
    max_resource_limit = structure[&#34;resources&#34;][resource][&#34;max&#34;]
    current_resource_limit = structure[&#34;resources&#34;][resource][&#34;usage&#34;]
    difference = max_resource_limit - current_resource_limit
    energy_aplification = CPU_SHARES_PER_WATT  # How many cpu shares to rescale per watt
    return int(difference * energy_aplification)}</code></pre>
</details>
</dd>
<dt id="src.Guardian.Guardian.Guardian.is_application"><code class="name flex">
<span>def <span class="ident">is_application</span></span>(<span>structure)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@staticmethod
def is_application(structure):
    return structure[&#34;subtype&#34;] == &#34;application&#34;}</code></pre>
</details>
</dd>
<dt id="src.Guardian.Guardian.Guardian.is_container"><code class="name flex">
<span>def <span class="ident">is_container</span></span>(<span>structure)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@staticmethod
def is_container(structure):
    return structure[&#34;subtype&#34;] == &#34;container&#34;}</code></pre>
</details>
</dd>
<dt id="src.Guardian.Guardian.Guardian.reduce_structure_events"><code class="name flex">
<span>def <span class="ident">reduce_structure_events</span></span>(<span>structure_events)</span>
</code></dt>
<dd>
<section class="desc"><dl>
<dt><strong><code>Parameters</code></strong></dt>
<dd>structure_events : list -&gt;</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A dictionary with the added up events in a signle dictionary</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@staticmethod
def reduce_structure_events(structure_events):
    &#34;&#34;&#34;
    Parameters:
        structure_events : list -&gt;

    Returns:
        A dictionary with the added up events in a signle dictionary
    &#34;&#34;&#34;
    events_reduced = {&#34;action&#34;: {}}
    for event in structure_events:
        resource = event[&#34;resource&#34;]
        if resource not in events_reduced[&#34;action&#34;]:
            events_reduced[&#34;action&#34;][resource] = {&#34;events&#34;: {&#34;scale&#34;: {&#34;down&#34;: 0, &#34;up&#34;: 0}}}
        for key in event[&#34;action&#34;][&#34;events&#34;][&#34;scale&#34;].keys():
            value = event[&#34;action&#34;][&#34;events&#34;][&#34;scale&#34;][key]
            events_reduced[&#34;action&#34;][resource][&#34;events&#34;][&#34;scale&#34;][key] += value
    return events_reduced[&#34;action&#34;]}</code></pre>
</details>
</dd>
<dt id="src.Guardian.Guardian.Guardian.sort_events"><code class="name flex">
<span>def <span class="ident">sort_events</span></span>(<span>structure_events, event_timeout)</span>
</code></dt>
<dd>
<section class="desc"><dl>
<dt><strong><code>Parameters</code></strong></dt>
<dd>structure_events : list -&gt; A list of the events triggered in the past for a specific structure
event_timeout : integer -&gt; A timeout in seconds</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A tuple of lists of events that either fall in the time window between
(now - timeout) and (now), the valid events, or outside of it, the invalid ones.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@staticmethod
def sort_events(structure_events, event_timeout):
    &#34;&#34;&#34;
    Parameters:
        structure_events : list -&gt; A list of the events triggered in the past for a specific structure
        event_timeout : integer -&gt; A timeout in seconds

    Returns:
        A tuple of lists of events that either fall in the time window between
        (now - timeout) and (now), the valid events, or outside of it, the invalid ones.
    &#34;&#34;&#34;
    valid, invalid = list(), list()
    for event in structure_events:
        if event[&#34;timestamp&#34;] &lt; time.time() - event_timeout:
            invalid.append(event)
        else:
            valid.append(event)
    return valid, invalid}</code></pre>
</details>
</dd>
<dt id="src.Guardian.Guardian.Guardian.try_get_value"><code class="name flex">
<span>def <span class="ident">try_get_value</span></span>(<span>d, key)</span>
</code></dt>
<dd>
<section class="desc"><dl>
<dt><strong><code>Parameters</code></strong></dt>
<dd>d : dict -&gt; A dictionary with strings as keys
key : string -&gt; A string used as key for a dictionary of integers</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The value stored in the dictionary or a specific value if it is not in it or if it is not an valid integer</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@staticmethod
def try_get_value(d, key):
    &#34;&#34;&#34;
    Parameters:
        d : dict -&gt; A dictionary with strings as keys
        key : string -&gt; A string used as key for a dictionary of integers

    Returns:
        The value stored in the dictionary or a specific value if it is not in it or if it is not an valid integer
    &#34;&#34;&#34;
    try:
        return int(d[key])
    except (KeyError, ValueError):
        return NOT_AVAILABLE_STRING}</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="src.Guardian.Guardian.Guardian.__init__"><code class="name flex">
<span>def <span class="ident">__init__</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Initialize self.
See help(type(self)) for accurate signature.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def __init__(self):
    self.opentsdb_handler = bdwatchdog.OpenTSDBServer()
    self.couchdb_handler = couchdb.CouchDBServer()
    self.NO_METRIC_DATA_DEFAULT_VALUE = self.opentsdb_handler.NO_METRIC_DATA_DEFAULT_VALUE
    self.guardable_resources = [&#39;cpu&#39;, &#39;mem&#39;, &#39;energy&#39;]
    self.debug = True}</code></pre>
</details>
</dd>
<dt id="src.Guardian.Guardian.Guardian.adjust_container_state"><code class="name flex">
<span>def <span class="ident">adjust_container_state</span></span>(<span>self, resources, limits)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def adjust_container_state(self, resources, limits):
    for resource in [&#34;cpu&#34;, &#34;mem&#34;]:
        errors = True
        while errors:
            try:
                self.check_invalid_container_state(resources, limits, resource)
                errors = False
            except ValueError:
                # Correct the chain current &gt; upper &gt; lower, including boundary between current and upper
                boundary = limits[resource][&#34;boundary&#34;]
                limits[resource][&#34;upper&#34;] = resources[resource][&#34;current&#34;] - boundary
                limits[resource][&#34;lower&#34;] = max(limits[resource][&#34;upper&#34;] - boundary, resources[resource][&#34;min&#34;])
    return limits}</code></pre>
</details>
</dd>
<dt id="src.Guardian.Guardian.Guardian.check_invalid_container_state"><code class="name flex">
<span>def <span class="ident">check_invalid_container_state</span></span>(<span>self, resources, limits, resource)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def check_invalid_container_state(self, resources, limits, resource):
    data = {&#34;res&#34;: resources, &#34;lim&#34;: limits}
    values_tuples = [(&#34;max&#34;, &#34;res&#34;), (&#34;current&#34;, &#34;res&#34;), (&#34;upper&#34;, &#34;lim&#34;), (&#34;lower&#34;, &#34;lim&#34;), (&#34;min&#34;, &#34;res&#34;)]
    values = dict()
    for value, vtype in values_tuples:
        values[value] = self.try_get_value(data[vtype][resource], value)
    values[&#34;boundary&#34;] = data[&#34;lim&#34;][resource][&#34;boundary&#34;]

    # Check values are set and valid, except for current as it may have not been persisted yet
    for value in values:
        self.check_unset_values(values[value], value)

    # Check if the first value is greater than the second
    # check the full chain &#34;max &gt; upper &gt; current &gt; lower &gt; min&#34;
    if values[&#34;current&#34;] != NOT_AVAILABLE_STRING:
        self.check_invalid_values(values[&#34;current&#34;], &#34;current&#34;, values[&#34;max&#34;], &#34;max&#34;)
    self.check_invalid_values(values[&#34;upper&#34;], &#34;upper&#34;, values[&#34;current&#34;], &#34;current&#34;, resource=resource)
    self.check_invalid_values(values[&#34;lower&#34;], &#34;lower&#34;, values[&#34;upper&#34;], &#34;upper&#34;, resource=resource)
    self.check_invalid_values(values[&#34;min&#34;], &#34;min&#34;, values[&#34;lower&#34;], &#34;lower&#34;, resource=resource)

    # Check that there is a boundary between values, like the current and upper, so
    # that the limit can be surpassed
    if values[&#34;current&#34;] != NOT_AVAILABLE_STRING:
        if values[&#34;current&#34;] - values[&#34;boundary&#34;] &lt; values[&#34;upper&#34;]:
            raise ValueError(
                &#34;value for &#39;current&#39;: {0} is too close (less than {1}) to value for &#39;upper&#39;: {2}&#34;.format(
                    str(values[&#34;current&#34;]), str(values[&#34;boundary&#34;]), str(values[&#34;upper&#34;])))

        elif values[&#34;current&#34;] - values[&#34;boundary&#34;] &gt; values[&#34;upper&#34;]:
            raise ValueError(
                &#34;value for &#39;current&#39;: {0} is too far (more than {1}) from value for &#39;upper&#39;: {2}&#34;.format(
                    str(values[&#34;current&#34;]), str(values[&#34;boundary&#34;]), str(values[&#34;upper&#34;])))}</code></pre>
</details>
</dd>
<dt id="src.Guardian.Guardian.Guardian.fixed_resource_amount"><code class="name flex">
<span>def <span class="ident">fixed_resource_amount</span></span>(<span>self, structure)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def fixed_resource_amount(self, structure):
    try:
        # Check if structure is guarded
        if &#34;guard&#34; not in structure or not structure[&#34;guard&#34;]:
            return

        self.process_fixed_resources_structure(structure[&#34;resources&#34;], structure)

    except Exception as e:
        MyUtils.log_error(
            &#34;error with structure: {0} {1} {2}&#34;.format(structure[&#34;name&#34;], str(e), str(traceback.format_exc())),
            self.debug)}</code></pre>
</details>
</dd>
<dt id="src.Guardian.Guardian.Guardian.get_container_energy_str"><code class="name flex">
<span>def <span class="ident">get_container_energy_str</span></span>(<span>self, resources_dict)</span>
</code></dt>
<dd>
<section class="desc"><dl>
<dt><strong><code>Parameters</code></strong></dt>
<dd>resources_dict : dict -&gt; A dictionary with all the resources' information</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A string that summarizes the state of the enery resource</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_container_energy_str(self, resources_dict):
    &#34;&#34;&#34;
    Parameters:
        resources_dict : dict -&gt; A dictionary with all the resources&#39; information

    Returns:
        A string that summarizes the state of the enery resource
    &#34;&#34;&#34;
    energy_dict = resources_dict[&#34;energy&#34;]
    string = list()
    for field in [&#34;max&#34;, &#34;usage&#34;, &#34;min&#34;]:
        string.append(str(self.try_get_value(energy_dict, field)))
    return &#34;,&#34;.join(string)}</code></pre>
</details>
</dd>
<dt id="src.Guardian.Guardian.Guardian.get_resource_summary"><code class="name flex">
<span>def <span class="ident">get_resource_summary</span></span>(<span>self, resource_label, resources_dict, limits_dict, usages_dict)</span>
</code></dt>
<dd>
<section class="desc"><dl>
<dt><strong><code>Parameters</code></strong></dt>
<dd>resource_label : string -&gt; the name of the resource to access the dictionaries
resources_dict : dict -&gt; a dictionary with the metrics (e.g., max, min) of the resources
limits_dict : dict -&gt; a dictionary with the limits (e.g., lower, upper) of the resources
usages_dict : dict -&gt; a dictionary with the usages of the resources</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A string that summarizes the state of a resource in terms of its metrics</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_resource_summary(self, resource_label, resources_dict, limits_dict, usages_dict):
    &#34;&#34;&#34;
    Parameters:
        resource_label : string -&gt; the name of the resource to access the dictionaries
        resources_dict : dict -&gt; a dictionary with the metrics (e.g., max, min) of the resources
        limits_dict : dict -&gt; a dictionary with the limits (e.g., lower, upper) of the resources
        usages_dict : dict -&gt; a dictionary with the usages of the resources

    Returns:
        A string that summarizes the state of a resource in terms of its metrics
    &#34;&#34;&#34;
    metrics = resources_dict[resource_label]
    limits = limits_dict[resource_label]

    if not usages_dict or usages_dict[translator_dict[resource_label]] == self.NO_METRIC_DATA_DEFAULT_VALUE:
        usage_value_string = NOT_AVAILABLE_STRING
    else:
        usage_value_string = str(&#34;%.2f&#34; % usages_dict[translator_dict[resource_label]])

    strings = list()
    if not limits_dict and not usages_dict:
        for field in [&#34;max&#34;, &#34;current&#34;, &#34;max&#34;, &#34;min&#34;]:
            strings.append(str(self.try_get_value(metrics, field)))
    else:
        for field in [(&#34;max&#34;, metrics), (&#34;current&#34;, metrics), (&#34;upper&#34;, limits), (&#34;lower&#34;, limits),
                      (&#34;min&#34;, metrics)]:
            strings.append(str(self.try_get_value(field[1], field[0])))
        strings.insert(3, usage_value_string)  # Manually add the usage metric

    return &#34;,&#34;.join(strings)}</code></pre>
</details>
</dd>
<dt id="src.Guardian.Guardian.Guardian.guard"><code class="name flex">
<span>def <span class="ident">guard</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def guard(self, ):
    logging.basicConfig(filename=SERVICE_NAME + &#39;.log&#39;, level=logging.INFO)
    while True:

        # Get service info
        service = MyUtils.get_service(self.couchdb_handler, SERVICE_NAME)

        # Heartbeat
        MyUtils.beat(self.couchdb_handler, SERVICE_NAME)

        # CONFIG
        config = service[&#34;config&#34;]
        self.debug = MyUtils.get_config_value(config, CONFIG_DEFAULT_VALUES, &#34;DEBUG&#34;)
        window_difference = MyUtils.get_config_value(config, CONFIG_DEFAULT_VALUES, &#34;WINDOW_TIMELAPSE&#34;)
        structure_guarded = MyUtils.get_config_value(config, CONFIG_DEFAULT_VALUES, &#34;STRUCTURE_GUARDED&#34;)
        thread = None

        # Remote database operation
        structures = MyUtils.get_structures(self.couchdb_handler, self.debug, subtype=structure_guarded)
        if structures:
            thread = Thread(target=self.guard_structures, args=(config, structures,))
            thread.start()

        MyUtils.log_info(
            &#34;Epoch processed at {0}&#34;.format(MyUtils.get_time_now_string()), self.debug)
        time.sleep(window_difference)

        if thread and thread.isAlive():
            delay_start = time.time()
            MyUtils.log_warning(
                &#34;Previous thread didn&#39;t finish before next poll is due, with window time of &#34; +
                &#34;{0} seconds, at {1}&#34;.format(str(window_difference), MyUtils.get_time_now_string()), self.debug)
            MyUtils.log_warning(&#34;Going to wait until thread finishes before proceeding&#34;, self.debug)
            thread.join()
            delay_end = time.time()
            MyUtils.log_warning(&#34;Resulting delay of: {0} seconds&#34;.format(str(delay_end - delay_start)),
                                self.debug)}</code></pre>
</details>
</dd>
<dt id="src.Guardian.Guardian.Guardian.guard_structures"><code class="name flex">
<span>def <span class="ident">guard_structures</span></span>(<span>self, config, structures)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def guard_structures(self, config, structures):
    # Remote database operation
    rules = self.couchdb_handler.get_rules()

    for structure in structures:
        if &#34;guard_policy&#34; not in structure:
            # Default option will be serverless
            self.serverless(config, structure, rules)
        else:
            if structure[&#34;guard_policy&#34;] == &#34;serverless&#34;:
                self.serverless(config, structure, rules)
            elif structure[&#34;guard_policy&#34;] == &#34;fixed&#34;:
                self.fixed_resource_amount(structure)
            else:
                self.serverless(config, structure, rules)}</code></pre>
</details>
</dd>
<dt id="src.Guardian.Guardian.Guardian.match_rules_and_events"><code class="name flex">
<span>def <span class="ident">match_rules_and_events</span></span>(<span>self, structure, rules, events, limits, usages)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def match_rules_and_events(self, structure, rules, events, limits, usages):
    generated_requests = list()
    events_to_remove = dict()
    for rule in rules:
        try:
            resource_label = rule[&#34;resource&#34;]
            if rule[&#34;active&#34;] and rule[&#34;generates&#34;] == &#34;requests&#34; and resource_label in events and jsonLogic(
                    rule[&#34;rule&#34;], events[resource_label]):

                # If rescaling a container, check that the current resource value exists, otherwise there
                # is nothing to rescale
                if self.is_container(structure) and &#34;current&#34; not in structure[&#34;resources&#34;][resource_label]:
                    MyUtils.log_warning(
                        &#34;No current value for container&#39; {0}&#39; and resource &#39;{1}&#39;, can&#39;t rescale&#34;.format(
                            structure[&#34;name&#34;], resource_label), self.debug)
                    continue

                # If no policy is set for scaling, default to &#34;fixed amount&#34;
                if &#34;rescale_by&#34; not in rule.keys():
                    rule[&#34;rescale_by&#34;] = &#34;amount&#34;
                    MyUtils.log_warning(
                        &#34;No rescale_by policy is set in rule : &#39;{0}&#39;, falling back to default amount&#34;.format(
                            rule[&#34;name&#34;]), self.debug)

                # Get the amount to be applied from the policy set
                if rule[&#34;rescale_by&#34;] == &#34;amount&#34;:
                    amount = rule[&#34;amount&#34;]
                elif rule[&#34;rescale_by&#34;] == &#34;percentage_reduction&#34;:
                    amount = self.get_amount_from_percentage_reduction(
                        structure, usages, resource_label, int(rule[&#34;percentage_reduction&#34;]))
                elif rule[&#34;rescale_by&#34;] == &#34;fit_to_usage&#34;:
                    current_resource_limit = structure[&#34;resources&#34;][resource_label][&#34;current&#34;]
                    boundary = limits[resource_label][&#34;boundary&#34;]
                    usage = usages[translator_dict[resource_label]]
                    amount = self.get_amount_from_fit_reduction(current_resource_limit, boundary, usage)
                elif rule[&#34;rescale_by&#34;] == &#34;proportional&#34; and rule[&#34;resource&#34;] == &#34;energy&#34;:
                    amount = self.get_amount_from_proportional_energy_rescaling(structure, resource_label)
                else:
                    amount = rule[&#34;amount&#34;]

                # If the resource is susceptible to check, ensure that it does not surpass any limit
                if resource_label not in NON_ADJUSTABLE_RESOURCES:
                    structure_resources = structure[&#34;resources&#34;][resource_label]
                    structure_limits = limits[resource_label]
                    amount = self.adjust_amount(amount, structure_resources, structure_limits)

                # Create the Request
                request = dict(
                    type=&#34;request&#34;,
                    resource=resource_label,
                    amount=int(amount),
                    structure=structure[&#34;name&#34;],
                    action=MyUtils.generate_request_name(amount, resource_label),
                    timestamp=int(time.time()))

                # For the moment, energy rescaling is uniquely mapped to cpu rescaling
                if resource_label == &#34;energy&#34;:
                    request[&#34;resource&#34;] = &#34;cpu&#34;
                    request[&#34;for_energy&#34;] = True

                # If scaling a container, add its host information as it will be needed
                if self.is_container(structure):
                    request[&#34;host&#34;] = structure[&#34;host&#34;]
                    request[&#34;host_rescaler_ip&#34;] = structure[&#34;host_rescaler_ip&#34;]
                    request[&#34;host_rescaler_port&#34;] = structure[&#34;host_rescaler_port&#34;]

                # Append the generated request
                generated_requests.append(request)

                # Remove the events that triggered the request
                event_name = MyUtils.generate_event_name(events[resource_label][&#34;events&#34;], resource_label)
                if event_name not in events_to_remove:
                    events_to_remove[event_name] = 0
                events_to_remove[event_name] += rule[&#34;events_to_remove&#34;]

        except KeyError as e:
            MyUtils.log_warning(
                &#34;rule: {0} is missing a parameter {1} {2} &#34;.format(rule[&#34;name&#34;], str(e),
                                                                   str(traceback.format_exc())), self.debug)

    return generated_requests, events_to_remove}</code></pre>
</details>
</dd>
<dt id="src.Guardian.Guardian.Guardian.match_usages_and_limits"><code class="name flex">
<span>def <span class="ident">match_usages_and_limits</span></span>(<span>self, structure_name, rules, usages, limits, resources)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def match_usages_and_limits(self, structure_name, rules, usages, limits, resources):
    events = []
    data = dict()

    for resource in self.guardable_resources:
        if resource in resources:
            data[resource] = {
                &#34;limits&#34;: {resource: limits[resource]},
                &#34;structure&#34;: {resource: resources[resource]}}

    for usage_metric in usages:
        keys = usage_metric.split(&#34;.&#34;)
        # Split the key from the retrieved data, e.g., structure.mem.usages, where mem is the resource
        data[keys[1]][keys[0]][keys[1]][keys[2]] = usages[usage_metric]

    for rule in rules:
        try:
            # Check that the rule is active, the resource to watch is guarded and that the rule is activated
            if rule[&#34;active&#34;] and \
                    resources[rule[&#34;resource&#34;]][&#34;guard&#34;] and \
                    rule[&#34;generates&#34;] == &#34;events&#34; and \
                    jsonLogic(rule[&#34;rule&#34;], data[rule[&#34;resource&#34;]]):

                event_name = MyUtils.generate_event_name(rule[&#34;action&#34;][&#34;events&#34;], rule[&#34;resource&#34;])
                if event_name:
                    events.append(dict(
                        name=event_name,
                        resource=rule[&#34;resource&#34;],
                        type=&#34;event&#34;,
                        structure=structure_name,
                        action=rule[&#34;action&#34;],
                        timestamp=int(time.time()))
                    )
        except KeyError as e:
            MyUtils.log_warning(
                &#34;rule: {0} is missing a parameter {1} {2}&#34;.format(rule[&#34;name&#34;],
                                                                  str(e), str(traceback.format_exc())), self.debug)

    return events}</code></pre>
</details>
</dd>
<dt id="src.Guardian.Guardian.Guardian.print_structure_info"><code class="name flex">
<span>def <span class="ident">print_structure_info</span></span>(<span>self, container, usages, limits, triggered_events, triggered_requests)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def print_structure_info(self, container, usages, limits, triggered_events, triggered_requests):
    resources = container[&#34;resources&#34;]

    container_name_str = &#34;@&#34; + container[&#34;name&#34;]
    container_guard_policy_str = &#34;with policy: {0}&#34;.format(container[&#34;guard_policy&#34;])
    resources_str = &#34;cpu({0}) - mem({1}) - energy({2})&#34;.format(
        self.get_resource_summary(&#34;cpu&#34;, resources, limits, usages),
        self.get_resource_summary(&#34;mem&#34;, resources, limits, usages),
        self.get_container_energy_str(resources))

    ev, req = list(), list()
    for event in triggered_events:
        ev.append(event[&#34;name&#34;])
    for request in triggered_requests:
        req.append(request[&#34;action&#34;])
    triggered_requests_and_events = &#34;#TRIGGERED EVENTS {0} AND TRIGGERED REQUESTS {1}&#34;.format(str(ev), str(req))
    MyUtils.log_info(
        &#34; &#34;.join([container_name_str, container_guard_policy_str, resources_str, triggered_requests_and_events]),
        self.debug)}</code></pre>
</details>
</dd>
<dt id="src.Guardian.Guardian.Guardian.process_fixed_resources_structure"><code class="name flex">
<span>def <span class="ident">process_fixed_resources_structure</span></span>(<span>self, resources, structure)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def process_fixed_resources_structure(self, resources, structure):
    triggered_requests = list()
    for resource in resources:
        if not resources[resource][&#34;guard&#34;]:
            continue

        if &#34;fixed&#34; in structure[&#34;resources&#34;][resource] and &#34;current&#34; in structure[&#34;resources&#34;][resource]:
            fixed_value = structure[&#34;resources&#34;][resource][&#34;fixed&#34;]
            current_value = structure[&#34;resources&#34;][resource][&#34;current&#34;]
            if fixed_value != current_value:
                amount = fixed_value - current_value
                request = dict(
                    type=&#34;request&#34;,
                    resource=resource,
                    amount=int(amount),
                    structure=structure[&#34;name&#34;],
                    action=MyUtils.generate_request_name(amount, resource),
                    timestamp=int(time.time()))

                if self.is_container(structure):
                    request[&#34;host&#34;] = structure[&#34;host&#34;]
                    request[&#34;host_rescaler_ip&#34;] = structure[&#34;host_rescaler_ip&#34;]
                    request[&#34;host_rescaler_port&#34;] = structure[&#34;host_rescaler_port&#34;]

                # Remote database operation
                self.couchdb_handler.add_request(request)
                triggered_requests.append(request)
        else:
            MyUtils.log_warning(
                &#34;structure: {0} has no &#39;current&#39; or &#39;fixed&#39; value for resource: {1}&#34;.format(
                    structure[&#34;name&#34;], resource), self.debug)

    # DEBUG AND INFO OUTPUT
    if self.debug:
        self.print_structure_info(structure, {}, {}, [], triggered_requests)}</code></pre>
</details>
</dd>
<dt id="src.Guardian.Guardian.Guardian.process_serverless_structure"><code class="name flex">
<span>def <span class="ident">process_serverless_structure</span></span>(<span>self, config, structure, usages, limits, rules)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def process_serverless_structure(self, config, structure, usages, limits, rules):
    event_timeout = MyUtils.get_config_value(config, CONFIG_DEFAULT_VALUES, &#34;EVENT_TIMEOUT&#34;)

    # Match usages and rules to generate events
    triggered_events = self.match_usages_and_limits(structure[&#34;name&#34;], rules, usages, limits,
                                                    structure[&#34;resources&#34;])

    # Remote database operation
    self.couchdb_handler.add_events(triggered_events)

    # Remote database operation
    all_events = self.couchdb_handler.get_events(structure)

    # Filter the events according to timestamp
    filtered_events, old_events = self.sort_events(all_events, event_timeout)

    if old_events:
        # Remote database operation
        self.couchdb_handler.delete_events(old_events)

    # If there are no events, nothing else to do as no requests will be generated
    if filtered_events:
        # Merge all the event counts
        reduced_events = self.reduce_structure_events(filtered_events)

        # Match events and rules to generate requests
        triggered_requests, events_to_remove = self.match_rules_and_events(structure, rules, reduced_events, limits,
                                                                           usages)

        # Remove events that generated the request
        # Remote database operation
        for event in events_to_remove:
            self.couchdb_handler.delete_num_events_by_structure(structure, event, events_to_remove[event])

        if triggered_requests:
            # Remote database operation
            self.couchdb_handler.add_requests(triggered_requests)

    else:
        triggered_requests = list()

    # DEBUG AND INFO OUTPUT
    if self.debug:
        self.print_structure_info(structure, usages, limits, triggered_events, triggered_requests)}</code></pre>
</details>
</dd>
<dt id="src.Guardian.Guardian.Guardian.serverless"><code class="name flex">
<span>def <span class="ident">serverless</span></span>(<span>self, config, structure, rules)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def serverless(self, config, structure, rules):
    window_difference = MyUtils.get_config_value(config, CONFIG_DEFAULT_VALUES, &#34;WINDOW_TIMELAPSE&#34;)
    window_delay = MyUtils.get_config_value(config, CONFIG_DEFAULT_VALUES, &#34;WINDOW_DELAY&#34;)

    try:
        # Check if structure is guarded
        if &#34;guard&#34; not in structure or not structure[&#34;guard&#34;]:
            return

        # Check if structure is being monitored, otherwise, ignore
        try:
            metrics_to_retrieve = BDWATCHDOG_METRICS[structure[&#34;subtype&#34;]]
            metrics_to_generate = GUARDIAN_METRICS[structure[&#34;subtype&#34;]]
            tag = TAGS[structure[&#34;subtype&#34;]]
        except KeyError:
            # Default is container
            metrics_to_retrieve = BDWATCHDOG_CONTAINER_METRICS
            metrics_to_generate = GUARDIAN_CONTAINER_METRICS
            tag = &#34;host&#34;

        # Remote database operation
        usages = self.opentsdb_handler.get_structure_timeseries({tag: structure[&#34;name&#34;]}, window_difference,
                                                                window_delay,
                                                                metrics_to_retrieve, metrics_to_generate)

        # Skip this structure if all the usage metrics are unavailable
        if all([usages[metric] == self.NO_METRIC_DATA_DEFAULT_VALUE for metric in usages]):
            MyUtils.log_warning(&#34;structure: {0} has no usage data&#34;.format(structure[&#34;name&#34;]), self.debug)
            return

        resources = structure[&#34;resources&#34;]

        # Remote database operation
        limits = self.couchdb_handler.get_limits(structure)
        limits_resources = limits[&#34;resources&#34;]

        if not limits_resources:
            MyUtils.log_warning(&#34;structure: {0} has no limits&#34;.format(structure[&#34;name&#34;]), self.debug)
            return

        limits[&#34;resources&#34;] = self.adjust_container_state(resources, limits_resources)

        # Remote database operation
        self.couchdb_handler.update_limit(limits)

        self.process_serverless_structure(config, structure, usages, limits_resources, rules)

    except Exception as e:
        MyUtils.log_error(
            &#34;error with structure: {0} {1} {2}&#34;.format(structure[&#34;name&#34;], str(e), str(traceback.format_exc())),
            self.debug)}</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="src.Guardian.Guardian.main" href="#src.Guardian.Guardian.main">main</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.Guardian.Guardian.Guardian" href="#src.Guardian.Guardian.Guardian">Guardian</a></code></h4>
<ul class="two-column">
<li><code><a title="src.Guardian.Guardian.Guardian.__init__" href="#src.Guardian.Guardian.Guardian.__init__">__init__</a></code></li>
<li><code><a title="src.Guardian.Guardian.Guardian.adjust_amount" href="#src.Guardian.Guardian.Guardian.adjust_amount">adjust_amount</a></code></li>
<li><code><a title="src.Guardian.Guardian.Guardian.adjust_container_state" href="#src.Guardian.Guardian.Guardian.adjust_container_state">adjust_container_state</a></code></li>
<li><code><a title="src.Guardian.Guardian.Guardian.check_invalid_container_state" href="#src.Guardian.Guardian.Guardian.check_invalid_container_state">check_invalid_container_state</a></code></li>
<li><code><a title="src.Guardian.Guardian.Guardian.check_invalid_values" href="#src.Guardian.Guardian.Guardian.check_invalid_values">check_invalid_values</a></code></li>
<li><code><a title="src.Guardian.Guardian.Guardian.check_unset_values" href="#src.Guardian.Guardian.Guardian.check_unset_values">check_unset_values</a></code></li>
<li><code><a title="src.Guardian.Guardian.Guardian.fixed_resource_amount" href="#src.Guardian.Guardian.Guardian.fixed_resource_amount">fixed_resource_amount</a></code></li>
<li><code><a title="src.Guardian.Guardian.Guardian.get_amount_from_fit_reduction" href="#src.Guardian.Guardian.Guardian.get_amount_from_fit_reduction">get_amount_from_fit_reduction</a></code></li>
<li><code><a title="src.Guardian.Guardian.Guardian.get_amount_from_percentage_reduction" href="#src.Guardian.Guardian.Guardian.get_amount_from_percentage_reduction">get_amount_from_percentage_reduction</a></code></li>
<li><code><a title="src.Guardian.Guardian.Guardian.get_amount_from_proportional_energy_rescaling" href="#src.Guardian.Guardian.Guardian.get_amount_from_proportional_energy_rescaling">get_amount_from_proportional_energy_rescaling</a></code></li>
<li><code><a title="src.Guardian.Guardian.Guardian.get_container_energy_str" href="#src.Guardian.Guardian.Guardian.get_container_energy_str">get_container_energy_str</a></code></li>
<li><code><a title="src.Guardian.Guardian.Guardian.get_resource_summary" href="#src.Guardian.Guardian.Guardian.get_resource_summary">get_resource_summary</a></code></li>
<li><code><a title="src.Guardian.Guardian.Guardian.guard" href="#src.Guardian.Guardian.Guardian.guard">guard</a></code></li>
<li><code><a title="src.Guardian.Guardian.Guardian.guard_structures" href="#src.Guardian.Guardian.Guardian.guard_structures">guard_structures</a></code></li>
<li><code><a title="src.Guardian.Guardian.Guardian.is_application" href="#src.Guardian.Guardian.Guardian.is_application">is_application</a></code></li>
<li><code><a title="src.Guardian.Guardian.Guardian.is_container" href="#src.Guardian.Guardian.Guardian.is_container">is_container</a></code></li>
<li><code><a title="src.Guardian.Guardian.Guardian.match_rules_and_events" href="#src.Guardian.Guardian.Guardian.match_rules_and_events">match_rules_and_events</a></code></li>
<li><code><a title="src.Guardian.Guardian.Guardian.match_usages_and_limits" href="#src.Guardian.Guardian.Guardian.match_usages_and_limits">match_usages_and_limits</a></code></li>
<li><code><a title="src.Guardian.Guardian.Guardian.print_structure_info" href="#src.Guardian.Guardian.Guardian.print_structure_info">print_structure_info</a></code></li>
<li><code><a title="src.Guardian.Guardian.Guardian.process_fixed_resources_structure" href="#src.Guardian.Guardian.Guardian.process_fixed_resources_structure">process_fixed_resources_structure</a></code></li>
<li><code><a title="src.Guardian.Guardian.Guardian.process_serverless_structure" href="#src.Guardian.Guardian.Guardian.process_serverless_structure">process_serverless_structure</a></code></li>
<li><code><a title="src.Guardian.Guardian.Guardian.reduce_structure_events" href="#src.Guardian.Guardian.Guardian.reduce_structure_events">reduce_structure_events</a></code></li>
<li><code><a title="src.Guardian.Guardian.Guardian.serverless" href="#src.Guardian.Guardian.Guardian.serverless">serverless</a></code></li>
<li><code><a title="src.Guardian.Guardian.Guardian.sort_events" href="#src.Guardian.Guardian.Guardian.sort_events">sort_events</a></code></li>
<li><code><a title="src.Guardian.Guardian.Guardian.try_get_value" href="#src.Guardian.Guardian.Guardian.try_get_value">try_get_value</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.5.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>